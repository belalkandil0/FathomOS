using System.IO;
using System.Text;
using FathomOS.Core.Models;

namespace FathomOS.Core.Export;

/// <summary>
/// Exports survey data to AutoCAD/BricsCAD script (.scr) format
/// </summary>
public class CadScriptExporter
{
    private readonly CadScriptOptions _options;

    public CadScriptExporter(CadScriptOptions? options = null)
    {
        _options = options ?? new CadScriptOptions();
    }

    /// <summary>
    /// Export survey data to CAD script file
    /// </summary>
    /// <param name="filePath">Output file path</param>
    /// <param name="points">Main survey points</param>
    /// <param name="route">Optional route data</param>
    /// <param name="project">Project settings</param>
    /// <param name="splinePoints">Optional spline-fitted points</param>
    /// <param name="intervalPoints">Optional interval measure points</param>
    public void Export(string filePath, IList<SurveyPoint> points, RouteData? route, Project project,
        IList<SurveyPoint>? splinePoints = null,
        IList<(double X, double Y, double Z, double Distance)>? intervalPoints = null)
    {
        using var writer = new StreamWriter(filePath, false, Encoding.ASCII);
        
        WriteHeader(writer, project);
        CreateLayers(writer, splinePoints != null, intervalPoints != null);

        // Draw route if available
        if (route != null && _options.IncludeRoute)
        {
            writer.WriteLine("; Route centerline");
            SetLayer(writer, "Route_Centerline");
            DrawRoute(writer, route);
        }

        // Draw survey track (using X, Y coordinates)
        if (points.Count > 0)
        {
            writer.WriteLine("; Survey track");
            SetLayer(writer, "Survey_Track");
            DrawTrack(writer, points);
        }

        // Draw 3D polyline if enabled
        if (_options.Include3DTrack && points.Any(p => p.CalculatedZ.HasValue))
        {
            writer.WriteLine("; 3D Survey track (seabed)");
            SetLayer(writer, "Survey_Track_3D");
            DrawTrack3D(writer, points);
        }

        // Draw KP labels
        if (_options.IncludeKpLabels && _options.KpLabelInterval > 0)
        {
            writer.WriteLine("; KP labels");
            SetLayer(writer, "KP_Labels");
            DrawKpLabels(writer, points);
        }

        // Draw survey fixes
        if (_options.IncludeFixes && project.SurveyFixes.Count > 0)
        {
            writer.WriteLine("; Survey fixes");
            SetLayer(writer, "Survey_Fixes");
            DrawFixes(writer, project.SurveyFixes);
        }
        
        // Draw spline-fitted track if provided
        if (splinePoints != null && splinePoints.Count > 1)
        {
            writer.WriteLine("; Spline-fitted track");
            SetLayer(writer, "Spline_Fit");
            DrawSplineTrack(writer, splinePoints);
        }
        
        // Draw interval points if provided
        if (intervalPoints != null && intervalPoints.Count > 0)
        {
            writer.WriteLine("; Interval measure points");
            SetLayer(writer, "Interval_Points");
            DrawIntervalPoints(writer, intervalPoints);
        }

        WriteFooter(writer);
    }

    /// <summary>
    /// Export 3D polyline script only
    /// </summary>
    public void Export3DPolyline(string filePath, IList<SurveyPoint> points, Project project, double depthExaggeration = 10.0)
    {
        using var writer = new StreamWriter(filePath, false, Encoding.ASCII);
        
        writer.WriteLine($"; 3D Polyline AutoCAD/BricsCAD Script");
        writer.WriteLine($"; Project: {project.ProjectName}");
        writer.WriteLine($"; Depth Exaggeration: {depthExaggeration}x");
        writer.WriteLine($"; Z = SeabedDepth × -1 × {depthExaggeration}");
        writer.WriteLine($"; Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        writer.WriteLine();

        // Create layer
        CreateLayer(writer, "Seabed_3D", 5); // Blue
        SetLayer(writer, "Seabed_3D");
        
        // Draw 3D polyline
        var validPoints = points.Where(p => p.CalculatedZ.HasValue).ToList();
        if (validPoints.Count >= 2)
        {
            writer.WriteLine("3DPOLY");
            foreach (var point in validPoints)
            {
                double z = -point.CalculatedZ!.Value * depthExaggeration;
                writer.WriteLine(FormatPoint3D(point.X, point.Y, z));
            }
            writer.WriteLine(""); // End 3DPOLY
        }

        WriteFooter(writer);
    }

    private void WriteHeader(StreamWriter writer, Project project)
    {
        writer.WriteLine($"; AutoCAD/BricsCAD Script File");
        writer.WriteLine($"; Generated by Fathom OS Survey Listing");
        writer.WriteLine($"; Project: {project.ProjectName}");
        writer.WriteLine($"; Client: {project.ClientName}");
        writer.WriteLine($"; Vessel: {project.VesselName}");
        writer.WriteLine($"; Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        writer.WriteLine($";");
        writer.WriteLine();

        // Open template if specified
        if (!string.IsNullOrEmpty(_options.TemplatePath))
        {
            writer.WriteLine($"; Opening template");
            writer.WriteLine($"OPEN");
            writer.WriteLine($"\"{_options.TemplatePath}\"");
            writer.WriteLine();
        }

        // Set units
        writer.WriteLine("; Set units");
        writer.WriteLine("UNITS");
        writer.WriteLine("2"); // Decimal
        writer.WriteLine(_options.DecimalPlaces.ToString()); // Precision
        writer.WriteLine(""); // Accept defaults for the rest
        writer.WriteLine();
    }

    private void CreateLayers(StreamWriter writer, bool includeSpline = false, bool includeInterval = false)
    {
        writer.WriteLine("; Create layers");
        
        CreateLayer(writer, "Route_Centerline", 1); // Red
        CreateLayer(writer, "Survey_Track", 3);     // Green
        CreateLayer(writer, "Survey_Track_3D", 5);  // Blue
        CreateLayer(writer, "Survey_Points", 4);    // Cyan
        CreateLayer(writer, "KP_Labels", 2);        // Yellow
        CreateLayer(writer, "Survey_Fixes", 6);     // Magenta
        
        if (includeSpline)
            CreateLayer(writer, "Spline_Fit", 40);  // Orange
        if (includeInterval)
            CreateLayer(writer, "Interval_Points", 6); // Magenta
        
        writer.WriteLine();
    }

    private void CreateLayer(StreamWriter writer, string name, int color)
    {
        writer.WriteLine("-LAYER");
        writer.WriteLine("M"); // Make
        writer.WriteLine(name);
        writer.WriteLine("C"); // Color
        writer.WriteLine(color.ToString());
        writer.WriteLine(""); // Apply to current layer
        writer.WriteLine(""); // Exit layer command
    }

    private void SetLayer(StreamWriter writer, string name)
    {
        writer.WriteLine("-LAYER");
        writer.WriteLine("S"); // Set
        writer.WriteLine(name);
        writer.WriteLine("");
    }

    private void DrawRoute(StreamWriter writer, RouteData route)
    {
        foreach (var segment in route.Segments)
        {
            if (segment.IsStraight)
            {
                // Draw line
                writer.WriteLine("LINE");
                writer.WriteLine(FormatPoint(segment.StartEasting, segment.StartNorthing));
                writer.WriteLine(FormatPoint(segment.EndEasting, segment.EndNorthing));
                writer.WriteLine(""); // End command
            }
            else
            {
                // Draw arc - AutoCAD arc command: ARC Start End Radius
                var (centerE, centerN) = segment.GetArcCenter();
                
                writer.WriteLine("ARC");
                writer.WriteLine("C"); // Center option
                writer.WriteLine(FormatPoint(centerE, centerN));
                writer.WriteLine(FormatPoint(segment.StartEasting, segment.StartNorthing));
                writer.WriteLine(FormatPoint(segment.EndEasting, segment.EndNorthing));
            }
        }
    }

    private void DrawTrack(StreamWriter writer, IList<SurveyPoint> points)
    {
        if (points.Count < 2)
            return;

        // Draw as polyline using X, Y (smoothed or raw coordinates)
        writer.WriteLine("PLINE");
        
        foreach (var point in points)
        {
            writer.WriteLine(FormatPoint(point.X, point.Y));
        }
        
        writer.WriteLine(""); // End polyline
    }

    private void DrawTrack3D(StreamWriter writer, IList<SurveyPoint> points)
    {
        var validPoints = points.Where(p => p.CalculatedZ.HasValue).ToList();
        if (validPoints.Count < 2)
            return;

        // Draw as 3D polyline using X, Y, Z
        writer.WriteLine("3DPOLY");
        
        foreach (var point in validPoints)
        {
            double z = -point.CalculatedZ!.Value * _options.DepthExaggeration;
            writer.WriteLine(FormatPoint3D(point.X, point.Y, z));
        }
        
        writer.WriteLine(""); // End 3DPOLY
    }

    private void DrawKpLabels(StreamWriter writer, IList<SurveyPoint> points)
    {
        if (points.Count == 0)
            return;

        double interval = _options.KpLabelInterval;
        var labeledKps = new HashSet<int>();

        foreach (var point in points)
        {
            if (!point.Kp.HasValue)
                continue;

            int kpInterval = (int)(point.Kp.Value / interval);
            
            if (!labeledKps.Contains(kpInterval))
            {
                labeledKps.Add(kpInterval);
                double labelKp = kpInterval * interval;

                // Draw tick mark (using X, Y)
                double tickSize = _options.TickSize;
                writer.WriteLine("LINE");
                writer.WriteLine(FormatPoint(point.X - tickSize, point.Y));
                writer.WriteLine(FormatPoint(point.X + tickSize, point.Y));
                writer.WriteLine("");

                // Draw text label
                string labelText = $"KP {labelKp:F3}";
                double textX = point.X + _options.TextOffset;
                double textY = point.Y + _options.TextOffset;

                writer.WriteLine("TEXT");
                writer.WriteLine(FormatPoint(textX, textY));
                writer.WriteLine(_options.TextHeight.ToString("F2")); // Text height
                writer.WriteLine("0"); // Rotation angle
                writer.WriteLine(labelText);
            }
        }
    }

    private void DrawFixes(StreamWriter writer, IList<SurveyFix> fixes)
    {
        foreach (var fix in fixes)
        {
            double size = _options.FixMarkerSize;
            
            // Draw X marker
            writer.WriteLine("LINE");
            writer.WriteLine(FormatPoint(fix.Easting - size, fix.Northing - size));
            writer.WriteLine(FormatPoint(fix.Easting + size, fix.Northing + size));
            writer.WriteLine("");

            writer.WriteLine("LINE");
            writer.WriteLine(FormatPoint(fix.Easting - size, fix.Northing + size));
            writer.WriteLine(FormatPoint(fix.Easting + size, fix.Northing - size));
            writer.WriteLine("");

            // Draw circle around marker
            writer.WriteLine("CIRCLE");
            writer.WriteLine(FormatPoint(fix.Easting, fix.Northing));
            writer.WriteLine((size * 1.5).ToString("F2"));

            // Draw label
            if (!string.IsNullOrEmpty(fix.Name))
            {
                writer.WriteLine("TEXT");
                writer.WriteLine(FormatPoint(fix.Easting + size * 2, fix.Northing));
                writer.WriteLine((_options.TextHeight * 0.8).ToString("F2"));
                writer.WriteLine("0");
                writer.WriteLine(fix.Name);
            }
        }
    }

    private void WriteFooter(StreamWriter writer)
    {
        writer.WriteLine();
        writer.WriteLine("; Zoom to extents");
        writer.WriteLine("ZOOM");
        writer.WriteLine("E");
        writer.WriteLine();
        writer.WriteLine("; Regenerate display");
        writer.WriteLine("REGEN");
        writer.WriteLine();
        writer.WriteLine("; End of script");
    }
    
    /// <summary>
    /// Draw spline-fitted track as polyline
    /// </summary>
    private void DrawSplineTrack(StreamWriter writer, IList<SurveyPoint> points)
    {
        if (points.Count < 2) return;
        
        writer.WriteLine("PLINE");
        foreach (var pt in points)
        {
            double x = pt.SmoothedEasting ?? pt.Easting;
            double y = pt.SmoothedNorthing ?? pt.Northing;
            writer.WriteLine(FormatPoint(x, y));
        }
        writer.WriteLine(""); // End polyline
    }
    
    /// <summary>
    /// Draw interval measure points
    /// </summary>
    private void DrawIntervalPoints(StreamWriter writer, IList<(double X, double Y, double Z, double Distance)> points)
    {
        // Draw as points
        foreach (var pt in points)
        {
            writer.WriteLine("POINT");
            writer.WriteLine(FormatPoint(pt.X, pt.Y));
        }
        
        // Also draw as polyline connecting the points
        if (points.Count > 1)
        {
            writer.WriteLine("PLINE");
            foreach (var pt in points)
            {
                writer.WriteLine(FormatPoint(pt.X, pt.Y));
            }
            writer.WriteLine(""); // End polyline
        }
    }

    private string FormatPoint(double x, double y)
    {
        string fmt = $"F{_options.DecimalPlaces}";
        return $"{x.ToString(fmt)},{y.ToString(fmt)}";
    }

    private string FormatPoint3D(double x, double y, double z)
    {
        string fmt = $"F{_options.DecimalPlaces}";
        return $"{x.ToString(fmt)},{y.ToString(fmt)},{z.ToString(fmt)}";
    }
}

/// <summary>
/// Options for CAD script export
/// </summary>
public class CadScriptOptions
{
    public string? TemplatePath { get; set; }
    public bool IncludeRoute { get; set; } = true;
    public bool IncludeKpLabels { get; set; } = true;
    public bool IncludeFixes { get; set; } = true;
    public bool Include3DTrack { get; set; } = false;
    
    public double KpLabelInterval { get; set; } = 1.0; // km
    public double TextHeight { get; set; } = 10.0;
    public double TextOffset { get; set; } = 15.0;
    public double TickSize { get; set; } = 5.0;
    public double FixMarkerSize { get; set; } = 10.0;
    public double DepthExaggeration { get; set; } = 10.0;
    public int DecimalPlaces { get; set; } = 4;
}
