namespace FathomOS.Shell.Licensing;

/// <summary>
/// Contains embedded cryptographic keys for license verification.
/// The public key is used to verify license signatures and is safe to distribute.
/// </summary>
public static class EmbeddedKeys
{
    /// <summary>
    /// ECDSA P-256 public key for verifying license signatures.
    /// This key is generated by the License Generator UI and is paired
    /// with a private key that is kept secret on the license server.
    ///
    /// This key is safe to distribute with the client application as it
    /// can only VERIFY signatures, not create them.
    /// </summary>
    public const string LicensePublicKey = @"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEFDbwi1nxZlWrSm5SqD8NFu6UprcV
jtY70iOte7R8umJSER7OmqYt/6xAkL2Y+7GXk1X79SRRlfF4S2GIZZpNvQ==
-----END PUBLIC KEY-----";

    /// <summary>
    /// Key ID for identifying which key version to use.
    /// This allows for key rotation without breaking existing licenses.
    /// </summary>
    public const string KeyId = "key-2026-01";

    /// <summary>
    /// Key version number.
    /// Increment this when rotating keys.
    /// </summary>
    public const int KeyVersion = 1;

    /// <summary>
    /// ECDSA P-256 public key for verifying certificate signatures.
    /// Used to verify processing certificates issued by FathomOS modules.
    /// </summary>
    public const string CertificatePublicKey = @"-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEFDbwi1nxZlWrSm5SqD8NFu6UprcV
jtY70iOte7R8umJSER7OmqYt/6xAkL2Y+7GXk1X79SRRlfF4S2GIZZpNvQ==
-----END PUBLIC KEY-----";

    /// <summary>
    /// Gets the public key in PEM format for license verification.
    /// </summary>
    public static string GetLicensePublicKeyPem() => LicensePublicKey;

    /// <summary>
    /// Gets the public key in PEM format for certificate verification.
    /// </summary>
    public static string GetCertificatePublicKeyPem() => CertificatePublicKey;

    /// <summary>
    /// Validates that the embedded keys are properly formatted.
    /// Call this at startup to detect any key corruption.
    /// </summary>
    /// <returns>True if keys are valid, false otherwise</returns>
    public static bool ValidateKeys()
    {
        try
        {
            // Check that license key has proper PEM format
            if (!LicensePublicKey.Contains("-----BEGIN PUBLIC KEY-----") ||
                !LicensePublicKey.Contains("-----END PUBLIC KEY-----"))
            {
                return false;
            }

            // Check that certificate key has proper PEM format
            if (!CertificatePublicKey.Contains("-----BEGIN PUBLIC KEY-----") ||
                !CertificatePublicKey.Contains("-----END PUBLIC KEY-----"))
            {
                return false;
            }

            // Extract base64 content and validate
            var licenseKeyContent = ExtractBase64Content(LicensePublicKey);
            var certKeyContent = ExtractBase64Content(CertificatePublicKey);

            if (string.IsNullOrEmpty(licenseKeyContent) || string.IsNullOrEmpty(certKeyContent))
            {
                return false;
            }

            // Try to decode base64
            var licenseBytes = Convert.FromBase64String(licenseKeyContent);
            var certBytes = Convert.FromBase64String(certKeyContent);

            // ECDSA P-256 public keys should be around 91 bytes in DER format
            return licenseBytes.Length >= 50 && certBytes.Length >= 50;
        }
        catch
        {
            return false;
        }
    }

    /// <summary>
    /// Extracts the base64 content from a PEM-formatted key.
    /// </summary>
    private static string ExtractBase64Content(string pemKey)
    {
        var lines = pemKey.Split('\n')
            .Select(l => l.Trim())
            .Where(l => !l.StartsWith("-----") && !string.IsNullOrEmpty(l));

        return string.Join("", lines);
    }
}
